<head>
    <link rel="stylesheet" href="/index.css">
    <title>Turing Machine</title>
</head>
<body>
    <center id="title">
        <h1>Turning Machine</h1>
    </center>

    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="cellPointer" fill="#ffffff" version="1.1" id="Layer_1" viewBox="0 0 330 330" xml:space="preserve"><path id="XMLID_225_" d="M325.607,79.393c-5.857-5.857-15.355-5.858-21.213,0.001l-139.39,139.393L25.607,79.393  c-5.857-5.857-15.355-5.858-21.213,0.001c-5.858,5.858-5.858,15.355,0,21.213l150.004,150c2.813,2.813,6.628,4.393,10.606,4.393  s7.794-1.581,10.606-4.394l149.996-150C331.465,94.749,331.465,85.251,325.607,79.393z"/></svg>
    
    <div id="tape">
        <div id="scroller" class="scrollerTransition" style="transition: 1s;"></div>
    </div>

    <br><br><br><br><br><br><br><br>

    <button onclick="isRunning=!isRunning">Toggle the machine</button>
    
    <script>
        const tapeScroller = document.getElementById("scroller")
        var skipAnimation = false
        var tapeScrollAnimation = tapeScroller.style.transition
        var tapeScrollAmount = 0
        var oneTapeCellWidth = 66 // 64px for cell with (.tapeCell>width) + 2px for border (:root>--tape-border-width)
        var validMemoryCells = []
        var currentMemoryIndex = 0

        var endingIdentifiers = ["HALT", "REJECT", "ACCEPT"]
        var BLANK_CHARACTER = "_"
        var initTapeCellValue = BLANK_CHARACTER

        // Write, value to put
        // Move, either "L" (left) or "R" (right)
        // Next State, the ID of the next state to become or "HALT" to end the program
        //      Can also return "REJECT" or "ACCEPT" which is halting but with a yes or no return
        class State{
            constructor(id, read="0", write="0", move="R", nextStateId=null){
                this.id = id
                
                this.read = read
                this.write = write
                this.move = move
                this.nextStateId = nextStateId
            }
        }
        
        var states = [
            // https://stackoverflow.com/questions/59045832/turing-machine-for-addition-and-comparison-of-binary-numbers
            // Move right to end of first block
            new State("0", "0", "0", "R", "0"),
            new State("0", "1", "1", "R", "0"),
            new State("0", BLANK_CHARACTER, BLANK_CHARACTER, "R", "1"),

            // Move right to end of second block
            new State("1", "0", "0", "R", "1"),
            new State("1", "1", "1", "R", "1"),
            new State("1", BLANK_CHARACTER, BLANK_CHARACTER, "L", "2"),

            // Subtract one in binary
            new State("2", "0", "1", "L", "2"),
            new State("2", "1", "0", "L", "3"),
            new State("2", BLANK_CHARACTER, BLANK_CHARACTER, "R", "5"),

            // Move left to end of first block
            new State("3", "0", "0", "L", "3"),
            new State("3", "1", "1", "L", "3"),
            new State("3", BLANK_CHARACTER, BLANK_CHARACTER, "L", "4"),

            // Add one in binary
            new State("4", "0", "1", "R", "0"),
            new State("4", "1", "0", "L", "4"),
            new State("4", BLANK_CHARACTER, "1", "R", "0"),

            // Clean up
            new State("5", "1", BLANK_CHARACTER, "R", "5"),
            new State("5", BLANK_CHARACTER, BLANK_CHARACTER, "HALT", "HALT"),
        ]
        var currentState = "q0"
        var isRunning = false
        var runningInterval = setInterval(()=>{
            if(isRunning == false){return}
            stepTuringMachine()
        }, 1100) // every 1.1s enough time for the animation to finish

        function stepTuringMachine(){
            let valueAtHeadElement = document.getElementById(currentMemoryIndex).firstChild

            let valueAtHead = valueAtHeadElement.innerText
            let currentStateObj = null
            for(let i=0; i<states.length; i++){
                let current = states[i]
                if(current.id != currentState){ continue }
                if(current.read != valueAtHead){ continue }
                
                currentStateObj = current
                break
            }

            // Write the value
            let writeValue = currentStateObj.write
            if(writeValue != null){
                valueAtHeadElement.innerText = currentStateObj.write
            }
            
            // Move head            
            let moveDir = currentStateObj.move
            
            if(moveDir == "L"){ moveTapeLeft() }
            else if(moveDir == "R"){ moveTapeRight() }
            else{
                if(endingIdentifiers.includes(moveDir) == false){
                    throw Error(`Move direction not valid!!! It is: "${moveDir}"`)
                }
            }

            // Set the next state
            currentState = currentStateObj.nextStateId
            if(endingIdentifiers.includes(currentState)){
                console.log(`Ending with state: ${currentState}`)
                clearInterval(runningInterval)
            }
        }





        // just enough to fill screen + 2
        // we will have 1 margin on each side
        var initMemoryCount = Math.ceil(window.innerWidth / oneTapeCellWidth) + 2
        moveTape(true, true)
        for(let i=0; i<initMemoryCount; i++){
            let value = initTapeCellValue
            //value = Math.round(Math.random())
            createNewTapeCellElement(value, true, i)
            
            validMemoryCells.push(i)
        }
        currentMemoryIndex = (Math.floor((initMemoryCount-2)/2)) + 1
        document.getElementById("cellPointer").style.left = `${(currentMemoryIndex-1) * oneTapeCellWidth}px`

        function max(list){
            let max = -Infinity
            for(let i=0; i<list.length; i++){
                if(list[i] > max){ max = list[i] }
            }
            return max
        }
        function min(list){
            let min = Infinity
            for(let i=0; i<list.length; i++){
                if(list[i] < min){ min = list[i] }
            }
            return min
        }

        function createElement(isLeft=false){
            // create a new element and move to it w/o the anim
            if(isLeft == true){
                let newId = max(validMemoryCells)+1
                createNewTapeCellElement(initTapeCellValue, true, newId)
                validMemoryCells.push(newId)
            }
            else{
                let newId = min(validMemoryCells)-1
                createNewTapeCellElement(initTapeCellValue, false, newId)
                validMemoryCells.push(newId)
                moveTape(true, true)
            }
        }

        function moveTape(isLeft=false, disableAnim=false){
            var moveBy = oneTapeCellWidth * (isLeft ? -1 : 1)
            tapeScrollAmount += moveBy
            
            if(disableAnim){ tapeScroller.style.transition = "" }
            else{ tapeScroller.style.transition = tapeScrollAnimation }
            updateTapeScroller()
        }
        function moveTapeRight(disableAnim=false){
            createElement(true) // create element to make it look inf
            setTimeout(()=>{moveTape(true, disableAnim)},2)
            currentMemoryIndex += 1
        }
        function moveTapeLeft(disableAnim=false){
            createElement(false) // create element to make it look inf
            setTimeout(()=>{moveTape(false, disableAnim)},2)
            currentMemoryIndex -= 1
        }

        function createNewTapeCellElement(value=0, append=true, id=null){
            var tapeCell = document.createElement("div")
            tapeCell.classList.add("tapeCell")
            if(id != null){ tapeCell.id = id }
            
            var cellValue = document.createElement("p")
            cellValue.innerText = value
            tapeCell.appendChild(cellValue)

            if(append == true){
                tapeScroller.appendChild(tapeCell)
            }
            else{
                tapeScroller.insertBefore(tapeCell, tapeScroller.firstChild)
            }
        }

        function updateTapeScroller(){
            tapeScroller.style.left = `${tapeScrollAmount}px`
        }
        //updateTapeScrollerInterval = setInterval(updateTapeScroller, 1)
    </script>
</body>