<head>
    <title>Turing Machine</title>

    <style>
        :root{
            --tape-border-width: 2px;
            --tape-cell-width: 64px;
        }


        body{
            background-color: rgb(38, 38, 38);
            color: white;
            font-family: monospace;
            margin: 0px;
        }

        #title{
            margin-top: 10px;
            text-align: center;
        }

        #tape{
            position: absolute;
            left: 0px;
            width: 100%;
            display: flex;

            border: var(--tape-border-width) solid white;
            border-left: none;
            border-right: none;
            overflow: hidden;
        }

        #cellPointer{
            width: var(--tape-cell-width);
            aspect-ratio: 1 / 1;
            
            position: relative;
            margin: var(--tape-border-width);
        }

        #currentState {
            text-align: center;
            font-size: 40px;
            margin: unset;

            background: transparent;
            border: none;
            color: white;

            width: var(--tape-cell-width);
            height: var(--tape-cell-width);
        }

        #scroller{
            position: relative;
            display: flex;
            left: 0px;
        }

        .tapeCell{
            border: var(--tape-border-width) solid white;
            border-top: none;
            border-bottom: none;

            width: var(--tape-cell-width);
            aspect-ratio: 1 / 1;
            position: relative;
            /* Compensate for the border so we don't have a really wide bar between two cells*/
            margin-right: calc(-1 * var(--tape-border-width));
        }

        .tapeCell input{
            margin: 0;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            width: var(--tape-cell-width);
            
            background: transparent;
            border: none;
            color: white;
            text-align: center;
        }
    </style>
</head>
<body>
    <center id="title">
        <h1>Turning Machine</h1>
    </center>

    <div id="cellPointer">
        <input id="currentState" value="0">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#ffffff" version="1.1" id="Layer_1" viewBox="0 0 330 330" xml:space="preserve"><path id="XMLID_225_" d="M325.607,79.393c-5.857-5.857-15.355-5.858-21.213,0.001l-139.39,139.393L25.607,79.393  c-5.857-5.857-15.355-5.858-21.213,0.001c-5.858,5.858-5.858,15.355,0,21.213l150.004,150c2.813,2.813,6.628,4.393,10.606,4.393  s7.794-1.581,10.606-4.394l149.996-150C331.465,94.749,331.465,85.251,325.607,79.393z"/></svg>
    </div>

    <div id="tape">
        <div id="scroller" class="scrollerTransition" style="transition: 1s;"></div>
    </div>

    <br><br><br><br><br><br><br><br>

    <button onclick="toggleMachine()" id="MachineToggleButton">Click to enable the machine</button>
    <br><br>
    <button onclick="stepTuringMachine()">Step Machine</button>
    <br><br>
    <button onclick="moveTapeLeft()">Move Left</button>
    <button onclick="moveTapeRight()">Move Right</button>
    
    <script>
        const tapeScroller = document.getElementById("scroller")
        const currentStateElement = document.getElementById("currentState")
        var skipAnimation = false
        var tapeScrollAnimation = tapeScroller.style.transition
        var tapeScrollAmount = 0
        var oneTapeCellWidth = 66 // 64px for cell with (.tapeCell>width) + 2px for border (:root>--tape-border-width)
        var validMemoryCells = []
        var currentMemoryIndex = 0

        var endingIdentifiers = ["HALT", "REJECT", "ACCEPT"]
        var endingIdentifiersToEmoji = {
            "HALT": "üõë",
            "REJECT": "‚ùå",
            "ACCEPT": "‚úÖ"
        }
        var BLANK_CHARACTER = "_"
        var initTapeCellValue = BLANK_CHARACTER

        // Write, value to put
        // Move, either "L" (left) or "R" (right)
        // Next State, the ID of the next state to become or "HALT" to end the program
        //      Can also return "REJECT" or "ACCEPT" which is halting but with a yes or no return
        class State{
            constructor(id, read="0", write="0", move="R", nextStateId=null){
                this.id = id
                
                this.read = read
                this.write = write
                this.move = move
                this.nextStateId = nextStateId
            }
        }
        
        /*
        var states = [
            // https://stackoverflow.com/questions/59045832/turing-machine-for-addition-and-comparison-of-binary-numbers
            // Move right to end of first block
            new State("0", "0", "0", "R", "0"),
            new State("0", "1", "1", "R", "0"),
            new State("0", BLANK_CHARACTER, BLANK_CHARACTER, "R", "1"),

            // Move right to end of second block
            new State("1", "0", "0", "R", "1"),
            new State("1", "1", "1", "R", "1"),
            new State("1", BLANK_CHARACTER, BLANK_CHARACTER, "L", "2"),

            // Subtract one in binary
            new State("2", "0", "1", "L", "2"),
            new State("2", "1", "0", "L", "3"),
            new State("2", BLANK_CHARACTER, BLANK_CHARACTER, "R", "5"),

            // Move left to end of first block
            new State("3", "0", "0", "L", "3"),
            new State("3", "1", "1", "L", "3"),
            new State("3", BLANK_CHARACTER, BLANK_CHARACTER, "L", "4"),

            // Add one in binary
            new State("4", "0", "1", "R", "0"),
            new State("4", "1", "0", "L", "4"),
            new State("4", BLANK_CHARACTER, "1", "R", "0"),

            // Clean up
            new State("5", "1", BLANK_CHARACTER, "R", "5"),
            new State("5", BLANK_CHARACTER, BLANK_CHARACTER, "HALT", "HALT"),
        ]
        */
        /*
        var states = [
            new State("0", "S", "S", "R", "CopyR10"),

            new State("CopyR10", "1", "1", "R", "Copy1R10"),
            new State("CopyR10", "0", "0", "R", "Copy0R10"),
            new State("CopyR10", "E", "E", "L", "HALT"),

            // Copy a 1
            new State("Copy1R10", "1", "1", "R", "Copy1R9"),
            new State("Copy1R10", "0", "0", "R", "Copy1R9"),
            new State("Copy1R10", BLANK_CHARACTER, BLANK_CHARACTER, "R", "Copy1R9"),
            new State("Copy1R10", "E", "E", "R", "Copy1R9"),

            new State("Copy1R9", "1", "1", "R", "Copy1R8"),
            new State("Copy1R9", "0", "0", "R", "Copy1R8"),
            new State("Copy1R9", BLANK_CHARACTER, BLANK_CHARACTER, "R", "Copy1R8"),
            new State("Copy1R9", "E", "E", "R", "Copy1R8"),
            
            new State("Copy1R8", "1", "1", "R", "Copy1R7"),
            new State("Copy1R8", "0", "0", "R", "Copy1R7"),
            new State("Copy1R8", BLANK_CHARACTER, BLANK_CHARACTER, "R", "Copy1R7"),
            new State("Copy1R8", "E", "E", "R", "Copy1R7"),
            
            new State("Copy1R7", "1", "1", "R", "Copy1R6"),
            new State("Copy1R7", "0", "0", "R", "Copy1R6"),
            new State("Copy1R7", BLANK_CHARACTER, BLANK_CHARACTER, "R", "Copy1R6"),
            new State("Copy1R7", "E", "E", "R", "Copy1R6"),
            
            new State("Copy1R6", "1", "1", "R", "Copy1R5"),
            new State("Copy1R6", "0", "0", "R", "Copy1R5"),
            new State("Copy1R6", BLANK_CHARACTER, BLANK_CHARACTER, "R", "Copy1R5"),
            new State("Copy1R6", "E", "E", "R", "Copy1R5"),
            
            new State("Copy1R5", "1", "1", "R", "Copy1R4"),
            new State("Copy1R5", "0", "0", "R", "Copy1R4"),
            new State("Copy1R5", BLANK_CHARACTER, BLANK_CHARACTER, "R", "Copy1R4"),
            new State("Copy1R5", "E", "E", "R", "Copy1R4"),
            
            new State("Copy1R4", "1", "1", "R", "Copy1R3"),
            new State("Copy1R4", "0", "0", "R", "Copy1R3"),
            new State("Copy1R4", BLANK_CHARACTER, BLANK_CHARACTER, "R", "Copy1R3"),
            new State("Copy1R4", "E", "E", "R", "Copy1R3"),
            
            new State("Copy1R3", "1", "1", "R", "Copy1R2"),
            new State("Copy1R3", "0", "0", "R", "Copy1R2"),
            new State("Copy1R3", BLANK_CHARACTER, BLANK_CHARACTER, "R", "Copy1R2"),
            new State("Copy1R3", "E", "E", "R", "Copy1R2"),
            
            new State("Copy1R2", "1", "1", "R", "Copy1R1"),
            new State("Copy1R2", "0", "0", "R", "Copy1R1"),
            new State("Copy1R2", BLANK_CHARACTER, BLANK_CHARACTER, "R", "Copy1R1"),
            new State("Copy1R2", "E", "E", "R", "Copy1R1"),

            new State("Copy1R1", "1", "1", "R", "Left10"),
            new State("Copy1R1", "0", "1", "R", "Left10"),
            new State("Copy1R1", BLANK_CHARACTER, "1", "R", "Left10"),
            new State("Copy1R1", "E", "E", "R", "Left10"),

            // Copy a 0
            new State("Copy0R10", "1", "1", "R", "Copy0R9"),
            new State("Copy0R10", "0", "0", "R", "Copy0R9"),
            new State("Copy0R10", BLANK_CHARACTER, BLANK_CHARACTER, "R", "Copy0R9"),
            new State("Copy0R10", "E", "E", "R", "Copy0R9"),

            new State("Copy0R9", "1", "1", "R", "Copy0R8"),
            new State("Copy0R9", "0", "0", "R", "Copy0R8"),
            new State("Copy0R9", BLANK_CHARACTER, BLANK_CHARACTER, "R", "Copy0R8"),
            new State("Copy0R9", "E", "E", "R", "Copy0R8"),
            
            new State("Copy0R8", "1", "1", "R", "Copy0R7"),
            new State("Copy0R8", "0", "0", "R", "Copy0R7"),
            new State("Copy0R8", BLANK_CHARACTER, BLANK_CHARACTER, "R", "Copy0R7"),
            new State("Copy0R8", "E", "E", "R", "Copy0R7"),
            
            new State("Copy0R7", "1", "1", "R", "Copy0R6"),
            new State("Copy0R7", "0", "0", "R", "Copy0R6"),
            new State("Copy0R7", BLANK_CHARACTER, BLANK_CHARACTER, "R", "Copy0R6"),
            new State("Copy0R7", "E", "E", "R", "Copy0R6"),
            
            new State("Copy0R6", "1", "1", "R", "Copy0R5"),
            new State("Copy0R6", "0", "0", "R", "Copy0R5"),
            new State("Copy0R6", BLANK_CHARACTER, BLANK_CHARACTER, "R", "Copy0R5"),
            new State("Copy0R6", "E", "E", "R", "Copy0R5"),
            
            new State("Copy0R5", "1", "1", "R", "Copy0R4"),
            new State("Copy0R5", "0", "0", "R", "Copy0R4"),
            new State("Copy0R5", BLANK_CHARACTER, BLANK_CHARACTER, "R", "Copy0R4"),
            new State("Copy0R5", "E", "E", "R", "Copy0R4"),
            
            new State("Copy0R4", "1", "1", "R", "Copy0R3"),
            new State("Copy0R4", "0", "0", "R", "Copy0R3"),
            new State("Copy0R4", BLANK_CHARACTER, BLANK_CHARACTER, "R", "Copy0R3"),
            new State("Copy0R4", "E", "E", "R", "Copy0R3"),
            
            new State("Copy0R3", "1", "1", "R", "Copy0R2"),
            new State("Copy0R3", "0", "0", "R", "Copy0R2"),
            new State("Copy0R3", BLANK_CHARACTER, BLANK_CHARACTER, "R", "Copy0R2"),
            new State("Copy0R3", "E", "E", "R", "Copy0R2"),
            
            new State("Copy0R2", "1", "1", "R", "Copy0R1"),
            new State("Copy0R2", "0", "0", "R", "Copy0R1"),
            new State("Copy0R2", BLANK_CHARACTER, BLANK_CHARACTER, "R", "Copy0R1"),
            new State("Copy0R2", "E", "E", "R", "Copy0R1"),

            new State("Copy0R1", "1", "0", "R", "Left10"),
            new State("Copy0R1", "0", "0", "R", "Left10"),
            new State("Copy0R1", BLANK_CHARACTER, "0", "R", "Left10"),
            new State("Copy0R1", "E", "E", "R", "Left10"),


            // go back to the value to copy
            
            new State("Left10", "1", "1", "L", "Left9"),
            new State("Left10", "0", "0", "L", "Left9"),
            new State("Left10", BLANK_CHARACTER, BLANK_CHARACTER, "L", "Left9"),
            new State("Left10", "E", "E", "L", "Left9"),

            new State("Left9", "1", "1", "L", "Left8"),
            new State("Left9", "0", "0", "L", "Left8"),
            new State("Left9", BLANK_CHARACTER, BLANK_CHARACTER, "L", "Left8"),
            new State("Left9", "E", "E", "L", "Left8"),

            new State("Left8", "1", "1", "L", "Left7"),
            new State("Left8", "0", "0", "L", "Left7"),
            new State("Left8", BLANK_CHARACTER, BLANK_CHARACTER, "L", "Left7"),
            new State("Left8", "E", "E", "L", "Left7"),

            new State("Left7", "1", "1", "L", "Left6"),
            new State("Left7", "0", "0", "L", "Left6"),
            new State("Left7", BLANK_CHARACTER, BLANK_CHARACTER, "L", "Left6"),
            new State("Left7", "E", "E", "L", "Left6"),

            new State("Left6", "1", "1", "L", "Left5"),
            new State("Left6", "0", "0", "L", "Left5"),
            new State("Left6", BLANK_CHARACTER, BLANK_CHARACTER, "L", "Left5"),
            new State("Left6", "E", "E", "L", "Left5"),

            new State("Left5", "1", "1", "L", "Left4"),
            new State("Left5", "0", "0", "L", "Left4"),
            new State("Left5", BLANK_CHARACTER, BLANK_CHARACTER, "L", "Left4"),
            new State("Left5", "E", "E", "L", "Left4"),

            new State("Left4", "1", "1", "L", "Left3"),
            new State("Left4", "0", "0", "L", "Left3"),
            new State("Left4", BLANK_CHARACTER, BLANK_CHARACTER, "L", "Left3"),
            new State("Left4", "E", "E", "L", "Left3"),

            new State("Left3", "1", "1", "L", "Left2"),
            new State("Left3", "0", "0", "L", "Left2"),
            new State("Left3", BLANK_CHARACTER, BLANK_CHARACTER, "L", "Left2"),
            new State("Left3", "E", "E", "L", "Left2"),

            new State("Left2", "1", "1", "L", "Left1"),
            new State("Left2", "0", "0", "L", "Left1"),
            new State("Left2", BLANK_CHARACTER, BLANK_CHARACTER, "L", "Left1"),
            new State("Left2", "E", "E", "L", "Left1"),

            new State("Left1", "1", "1", "L", "CopyR10"),
            new State("Left1", "0", "0", "L", "CopyR10"),
            new State("Left1", BLANK_CHARACTER, BLANK_CHARACTER, "L", "CopyR10"),
            new State("Left1", "E", "E", "L", "CopyR10"),
        ]
        */

        
        // Register setup
        // X00000000 Y00000000 A00000000 etc
        var states = [
            
        ]

        var currentState = "0"
        currentStateElement.value = currentState // first init
        var isRunning = false
        var runningInterval = setInterval(()=>{
            if(isRunning == false){return}
            stepTuringMachine()
        }, 1100) // every 1.1s enough time for the animation to finish

        currentStateElement.addEventListener("change", (event)=>{
            currentState = currentStateElement.value
        })

        function stepTuringMachine(){
            let valueAtHeadElement = document.getElementById(currentMemoryIndex).firstChild

            let valueAtHead = valueAtHeadElement.value
            let currentStateObj = null
            for(let i=0; i<states.length; i++){
                let current = states[i]
                if(current.id != currentState){ continue }

                if(current.read == null && currentStateObj == null){
                    // this is the default state, will be replaced by the right state if it exists
                    currentStateObj = current
                }
                if(current.read != valueAtHead){ continue }
                
                currentStateObj = current
                break
            }

            if(currentStateObj == null){
                throw Error(`No valid state rule found! Current State: "${currentState}" Read: "${valueAtHead}"`)
            }

            // Write the value
            let writeValue = currentStateObj.write
            if(writeValue != null){
                valueAtHeadElement.value = currentStateObj.write
            }
            
            // Move head            
            let moveDir = currentStateObj.move
            
            if(moveDir == "L"){ moveTapeLeft() }
            else if(moveDir == "R"){ moveTapeRight() }
            else{
                if(endingIdentifiers.includes(moveDir) == false){
                    throw Error(`Move direction not valid!!! It is: "${moveDir}"`)
                }
            }

            // Set the next state
            currentState = currentStateObj.nextStateId
            currentStateElement.value = currentState

            if(endingIdentifiers.includes(currentState)){
                console.log(`Ending with state: ${currentState}`)
                clearInterval(runningInterval)

                currentStateElement.value = endingIdentifiersToEmoji[currentState]
            }
        }

        function toggleMachine(){
            isRunning = !isRunning
            let newText = isRunning ? "Click to disable the machine" : "Click to enable the machine"
            document.getElementById("MachineToggleButton").innerText = newText
        }



        // just enough to fill screen + 2
        // we will have 1 margin on each side
        var initMemoryCount = Math.ceil(window.innerWidth / oneTapeCellWidth) + 2
        moveTape(true, true)
        for(let i=0; i<initMemoryCount; i++){
            let value = initTapeCellValue
            //value = Math.round(Math.random())
            createNewTapeCellElement(value, true, i)
            
            validMemoryCells.push(i)
        }
        currentMemoryIndex = (Math.floor((initMemoryCount-2)/2)) + 1
        document.getElementById("cellPointer").style.left = `${(currentMemoryIndex-1) * oneTapeCellWidth}px`

        function max(list){
            let max = -Infinity
            for(let i=0; i<list.length; i++){
                if(list[i] > max){ max = list[i] }
            }
            return max
        }
        function min(list){
            let min = Infinity
            for(let i=0; i<list.length; i++){
                if(list[i] < min){ min = list[i] }
            }
            return min
        }

        function createElement(isLeft=false){
            // create a new element and move to it w/o the anim
            if(isLeft == true){
                let newId = max(validMemoryCells)+1
                createNewTapeCellElement(initTapeCellValue, true, newId)
                validMemoryCells.push(newId)
            }
            else{
                let newId = min(validMemoryCells)-1
                createNewTapeCellElement(initTapeCellValue, false, newId)
                validMemoryCells.push(newId)
                moveTape(true, true)
            }
        }

        function moveTape(isLeft=false, disableAnim=false){
            var moveBy = oneTapeCellWidth * (isLeft ? -1 : 1)
            tapeScrollAmount += moveBy
            
            if(disableAnim){ tapeScroller.style.transition = "" }
            else{ tapeScroller.style.transition = tapeScrollAnimation }
            updateTapeScroller()
        }
        function moveTapeRight(disableAnim=false){
            createElement(true) // create element to make it look inf
            setTimeout(()=>{moveTape(true, disableAnim)},2)
            currentMemoryIndex += 1
        }
        function moveTapeLeft(disableAnim=false){
            createElement(false) // create element to make it look inf
            setTimeout(()=>{moveTape(false, disableAnim)},2)
            currentMemoryIndex -= 1
        }

        function createNewTapeCellElement(value=0, append=true, id=null){
            var tapeCell = document.createElement("div")
            tapeCell.classList.add("tapeCell")
            if(id != null){ tapeCell.id = id }
            
            var cellValue = document.createElement("input")
            cellValue.value = value
            cellValue.tabIndex = -1
            tapeCell.appendChild(cellValue)

            if(append == true){
                tapeScroller.appendChild(tapeCell)
            }
            else{
                tapeScroller.insertBefore(tapeCell, tapeScroller.firstChild)
            }
        }

        function updateTapeScroller(){
            tapeScroller.style.left = `${tapeScrollAmount}px`
        }
        //updateTapeScrollerInterval = setInterval(updateTapeScroller, 1)


        function isElementInViewport(el) {
            const rect = el.getBoundingClientRect();

            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }
        function isElementPartiallyInViewport(el) {
            const rect = el.getBoundingClientRect();

            return (
                rect.bottom >= 0 &&
                rect.right >= 0 &&
                rect.top <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.left <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }

        let isShiftPressed = false
        document.addEventListener('keyup', (e) => {
            if(e.key == "Shift"){ isShiftPressed = false }
        })
        document.addEventListener('keydown', (e) => {
            if(e.key == "Shift"){ isShiftPressed = true }
            if (e.key === 'Tab') {
                e.preventDefault();
                // Custom logic to focus next element manually
                let currentCellId = parseInt(document.activeElement.parentElement.id)
                let nextElementId = currentCellId + (isShiftPressed ? -1 : 1)
                let nextElement = document.getElementById(nextElementId)
                let hideScrollAnimation = true

                let moveFunc = isShiftPressed ? moveTapeLeft : moveTapeRight
                if(nextElement == null){ moveFunc(hideScrollAnimation) }
                else{
                    let checkVisibleFunction = isShiftPressed ? isElementInViewport : isElementPartiallyInViewport
                    if(checkVisibleFunction(nextElement) == false){ moveFunc(hideScrollAnimation) }
                }

                nextElement = document.getElementById(nextElementId)
                if(nextElement == null){ throw Error("idk what happened but I still can't find the next element to focus!") }

                let nextElementInput = nextElement.children[0]
                nextElementInput.focus({ preventScroll: true })
                nextElementInput.select()

                console.log(isElementInViewport(nextElementInput))
            }
        });
    </script>
</body>